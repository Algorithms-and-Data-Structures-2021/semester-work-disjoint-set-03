#pragma once

#include <vector>
#include <stdexcept>

namespace itis {

/**
 * Структура элемента
 * Элемент имеет ранг и значение родителя
 */
  struct Element {
   public:
    int rank{0};
    int parent{0};

    /**
     * Конструктор элемента
     * @param num - номер(значение) элемента
     * Изначально каждый элемент является своим же родителем
     */
    Element(int num) : parent{num} {}
  };

/**
 * Структура СД Disjoint-set
 * В данной простой реализации имеет n элементов,
 * где элемент имеет значение равное своему порядковому номеру. (Это не бесполезно. Смотрите пример =))
 * Элементы хранятся в массиве elements.
 * Реализована с использованием сжатия путей и Union-by-rank
 */
  struct DisjointSet {
   public:
    int subset_count{0};
    int size{0};
    std::vector<Element> elements;

    /**
     * Конструктор структуры данных
     * Он представляет собой make_set, выполненный n раз
     * @param n - количество элементов
     */
    DisjointSet(int n = 0);

    /**
     * Отдельный метод для создания подмножества с одним элементом
     * и присоединения его к множеству.
     */
    void make_set();

    /**
     * Поиск подмножества, к которому принадлежит элемент
     * Реализовано со сжатием путей
     * @param node - элемент
     * @return - представитель подмножества
     */
    int find(int node);

    /**
     * Объединение подмножеств, к которым принадлежат элементы
     * Реализовано с Union-by-rank для оптимизации СД
     * @param x - первый элемент
     * @param y - второй элемент
     */
    void join(int x, int y);
  };

}  // namespace itis